# Code for Command Executor of Shell 

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <err.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sysexits.h>
#include <sys/wait.h>

#include "command.h"
#include "executor.h"

#define OPEN_FLAGS (O_WRONLY | O_TRUNC | O_CREAT)
#define DEF_MODE 0664

static int execute_aux(struct tree *t, int p_input_fd, int p_output_fd);

int execute(struct tree *t) { 

  if (t != NULL){
  
    return execute_aux(t, STDIN_FILENO, STDOUT_FILENO);
  
  }
  
  return 0;

}


/****************************** Auxiliary Method ***********************/

static int execute_aux(struct tree *t, int p_input_fd, int p_output_fd) {
  int status;
  pid_t result, result2, result3;
  
  int pipe_fd[2];   /* pipe array 2 ends for read and write */
  
  if (t->conjunction == NONE){
  
    /* Handling Shell Commands */
    if ((strcmp(t->argv[0], "cd")) == 0){ /* cd command */
       
       if (t->argv[1] != NULL) {
         
         if ((chdir(t->argv[1])) == -1){
           perror(t->argv[1]); /* if changing directory was unsuccessful print error */
         
         }
       
       } else {
       
         if ((chdir(getenv("HOME"))) == -1){  /* change to home directory if no args given */
           perror("HOME"); /* if changing directory was unsuccessful print error */
           
         }
         
       }
       
       return 0;
     
    } else if ((strcmp(t->argv[0], "exit")) == 0){ /* exit command */
     
       exit(0); /* exit shell, return 0 for all successful processes */
    
    /* Handling Linux Commands */ 
    } else {
      
      /* Fork Call */
      if ((result = fork()) < 0){
        perror("Fork Failure\n"); /* if fork system call fails */
        exit(EX_OSERR);
      }
      
      if (result == 0){ /* Child Code */
        
        if (t->input != NULL){
         /* Open file for standard input, check for error */
         if ((p_input_fd = open(t->input, O_RDONLY)) < 0){
           perror("File Open Failure\n");
           exit(EX_OSERR);
         }
         
         /* Map input to standard input, check for error */
         if (dup2(p_input_fd, STDIN_FILENO) < 0){ 
           perror("File Open Failure\n");
           exit(EX_OSERR);
         } 
         
         if (close(p_input_fd) < 0){
           perror("File Open Failure\n");
           exit(EX_OSERR);
         }
        } else {
          dup2(p_input_fd, STDIN_FILENO);
        
        }
        
        
        if (t->output != NULL){
         /* Open output file, check for error */
         if ((p_output_fd = open(t->output, OPEN_FLAGS, DEF_MODE)) < 0){
           perror("File Open Failure\n");
           exit(EX_OSERR);
         }
         
         /* Map output file to standard output, check for error */
         if (dup2(p_output_fd, STDOUT_FILENO) < 0){ 
           perror("File Open Failure\n");
           exit(EX_OSERR);
         }
         
         /* Close file, check for error */
         if (close(p_output_fd) < 0){
           perror("File Open Failure\n");
           exit(EX_OSERR);
         }
        } else {
          dup2(p_output_fd, STDOUT_FILENO);
        
        }
        
        /* Use exec to execute command */
        if ((execvp(t->argv[0], t->argv)) < 0) {
           
           /* If exec fails */
           fprintf(stderr, "Failed to execute %s\n", t->argv[0]);
           fflush(stdout);
           exit(EX_OSERR);
         
         }
         exit(0);
      
      } else { /* Parent Code */
      
        wait(&status);
        return status;  /* End of Recursive Calls (Returns 0 if successful) */
      
      }
    
    } /* END OF NONE CONJUNCTION NODE */
  
  } else if (t->conjunction == AND) {
  
    /* Check file descriptors to pass to children */
    if (t->input != NULL){
      
      /* Open file to get input file descriptor, check for error */
      if ((p_input_fd = open(t->input, O_RDONLY)) < 0){
        perror("File Open Failure\n");
        exit(EX_OSERR);
      }
    }
    
    if (t->output != NULL){
    
      /* Open file to get output file descriptor, check for error */
      if ((p_output_fd = open(t->output, OPEN_FLAGS, DEF_MODE)) < 0){
        perror("File Open Failure\n");
        exit(EX_OSERR);
      }
    }
    
    /* Process left subtree and verify it was successful */
    /* Set variable for left subtree and return */
    if ((status = execute_aux(t->left, p_input_fd, p_output_fd)) == 0){
      
      /* Process right subtree */
      return execute_aux(t->right, p_input_fd, p_output_fd);

    } else {
    
      return status;
    
    } /* END OF AND CONJUCTION NODE */
  
  } else if (t->conjunction == PIPE) {
    
    /**************** Check for Ambiguous Redirect **********************/
      if (t->left->output != NULL){
        printf("Ambiguous output redirect.\n"); 
        fflush(stdout);
        return -1;
      }
      
      if (t->right->input != NULL){
        printf("Ambiguous input redirect.\n");
        fflush(stdout);
        return -1;
      }
    /********************************************************************/
    
    /* Create a pipe */
    if ((pipe(pipe_fd)) != 0){
      perror("File Open Failure\n");
      exit(EX_OSERR);
    }
    
    /* Then fork */ 
    if ((result2 = fork()) < 0){ 
      perror("Fork Failure\n"); /* if fork system call fails */
      exit(EX_OSERR);
    }
    
    if (result2 == 0){ /* Child Code */
    
      /* Process Right Subtree */
      
      if ((close(pipe_fd[1])) != 0){
        perror("File Open Failure\n");
        exit(EX_OSERR);
      
      }   /* Close the write end, not needed */
      
      /* Get output for processing right tree */
      if (t->output != NULL){
    
        /* Open file to get output file descriptor, check for error */
        if ((p_output_fd = open(t->output, OPEN_FLAGS, DEF_MODE)) < 0){
          perror("File Open Failure\n");
          exit(EX_OSERR);
        }
      }
      
      /* Process Right Subtree using input from pipe */
      execute_aux(t->right, pipe_fd[0], p_output_fd); /* read input from pipe */

      /* Close Pipe */
      if ((close(pipe_fd[0])) != 0){
        perror("File Open Failure\n");
        exit(EX_OSERR);
        
      } 
      exit(0);
    
    } else {  /* Parent Code */
    
      /* Process Left Subtree */
      if (close(pipe_fd[0])){
        perror("File Open Failure\n");
        exit(EX_OSERR);
      }   /* Close the read end, not needed */
      
      /* Get input for processing of left tree */
      
      /* Check file descriptors to pass to children */
      if (t->input != NULL){
        
        /* Open file to get input file descriptor, check for error */
        if ((p_input_fd = open(t->input, O_RDONLY)) < 0){
          perror("File Open Failure\n");
          exit(EX_OSERR);
        }
      } 
      
      /* Process left subtree and send output to pipe */
      execute_aux(t->left, p_input_fd, pipe_fd[1]);  /* Placing output in pipe */
      
      /* Close Pipe */
      if (close(pipe_fd[1])){
        perror("File Open Failure\n");
        exit(EX_OSERR);
      
      } 
      
      wait(&status);  /* Be sure to reap child, MAY HAVE TO CHECK STATUS */
      return status;
    }
    
  } else if (t->conjunction == SUBSHELL){
  
    /* Subshells only receive left subtree reference, so process left subtree */
    
    /* Child must process subshell */
    
    if ((result3 = fork()) < 0){
      perror("Fork Failure\n"); /* if fork system call fails */
      exit(EX_OSERR);
    }
    
    if (result3 == 0){ /*Child Code */
    
      /* Check input and output of subshell node */
      
      if (t->input != NULL){
        /* Open file to get input file descriptor, check for error */
        if ((p_input_fd = open(t->input, O_RDONLY)) < 0){
          perror("File Open Failure\n");
          exit(EX_OSERR);
        }
      }
      
      if (t->output != NULL){
        /* Open file to get output file descriptor, check for error */
        if ((p_output_fd = open(t->output, OPEN_FLAGS, DEF_MODE)) < 0){
          perror("File Open Failure\n");
          exit(EX_OSERR);
        }
      }
    
      /* Process left subtree */
      execute_aux(t->left, p_input_fd, p_output_fd);
      exit(0);
    
    } else { /* Parent Code */
    
      /* Reap child once finished */
      wait(&status);
      return status;
      
    } 
  
  } /* END OF SUBSHELL CONJUCTION */


  return 0;
}
